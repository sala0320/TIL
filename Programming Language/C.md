# C 
- [Pointer](#Pointer)
- [메모리 동적할당](#메모리-동적할당)
- [구조체](#구조체)
## Pointer

### 포인터를 사용하는 이유

주로 임베디드 프로그래밍을 할 때 메모리에 직접 접근하는 경우나, 동적 할당한 메모리를 사용하는 경우 사용

### & : 주소 연산자

```c
int a = 10;
printf("%u" &a); //2750392 
```

### * : 포인터 / 간접 참조 연산자

- int *p : 포인터 (주소 값을 저장하는 변수 / 주소값을 저장하는 다른 메모리 공간)
- *p : 간접 참조 연산자 (포인터가 가르키는 변수)

```c
int a; //일반 변수 선언
int *pointer; //포인터 선언

pointer = &a; // 포인터에 a의 주소 대입
*pointer = 10; // 포인터로 변수 a에 10 대입

printf("포인터로 a값 출력 : %d", *pa); // 포인터로 a값 출력 : 10
```

### 형 변환 포인터 대입

```c
double a = 3.4;
double *pd = &a; //pd가 double현 변수 a를 가리키도록 초기화
int *pi; //int형 변수를 가리키는 포인터

pi = (int *)pd; //pd 값을 형변환하여 pi에 대입
pi = pd //에러
```

### 배열과 포인터

배열은 자료형이 같은 변수를 메모리에 연속으로 할당한다. 따라서 배열 첫번째 요소의 주소를 알면 나머지 요소의 주소도 쉽게 알수 있고, 각 주소에 간접 참조 연산을 수행하면 모든 배열 요소를 사용할 수 있다.
```c
int arr[3];

*(arr + 0) = 10; //arr[0] = 10
*(arr + 1) = *(arr + 0) + 10; //arr[1] = arr[0] + 10 = 20
```
```c
int arr[3];
int *pa = arr; //포인터에 배열명 저장
int i;

*pa = 10; //첫번째 배열 요소에 10 대입
*(pa + 1) = 20; // 두번째 배열 요소에 20 대입
pa[2] = pa[0] + pa[1]; //30 = 10 + 20

for (i = 0; i < 3; i++)
{
	printf("%d\n", *(pa++)); //pa가 가르키는 배열의 요소 출력, 후위형 증가 연산
	printf("%d\n", pa[i]);
	printf("%d\n", arr[i]);
}

```

## 메모리 동적할당
## 구조체